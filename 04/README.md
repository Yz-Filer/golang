# 4. これに気をつけないとアプリが落ちます
GTK3アプリを作ってると、急にアプリが落ちることがあります。必ず特定の場所で落ちるのではなく、前回は問題なかった操作で落ちることもあります。  
Geminiに聞きながら、どこに気をつけるべきかを整理したいと思います。

## 4.1 GTK3とUIのメインループ
> GTK3のようなGUIツールキットでは、UIの更新やイベント処理を「メインループ」と呼ばれる特別なループの中で実行する必要があります。これは、以下の理由によります。  
> - イベント駆動型アーキテクチャ:  
>   GTK3は、ユーザーの操作（クリック、キー入力など）やシステムからの通知（ウィンドウの再描画など）を「イベント」として処理します。これらのイベントは、メインループが繰り返し実行される中で順番に処理されます。
> - シングルスレッド:  
>   GTK3は、基本的にシングルスレッドで動作します。つまり、UIの更新やイベント処理は、同一のスレッド内で順番に行われる必要があります。もし、UIの更新をメインループ以外の場所で行ってしまうと、スレッド間の競合が発生し、UIがフリーズしたり、クラッシュしたりする可能性があります。
> - 描画の同期:  
>   UIの描画は、特定のタイミングで行われる必要があります。メインループは、描画のタイミングを管理し、画面のちらつきや描画の乱れを防ぎます。

## 4.2 glib.IdleAddの必要性
> glib.IdleAddは、メインループがアイドル状態になったときに特定の関数を実行するための仕組みです。これは、以下の理由で必要になります。
> 
> - 時間のかかる処理の分離:  
>   メインループ内で時間のかかる処理（ファイルの読み込み、ネットワーク通信など）を行うと、UIの応答性が悪化します。glib.IdleAddを使うことで、時間のかかる処理をメインループから分離し、アイドル状態になったときに実行することができます。
> - UIの更新の遅延:  
>   イベント処理の結果としてUIを更新する必要がある場合、すぐに更新すると、他のイベント処理が遅延する可能性があります。glib.IdleAddを使うことで、UIの更新をアイドル状態まで遅延させ、他のイベント処理を優先することができます。
> - 非同期処理の結果の反映:  
>   非同期処理（別スレッドでの処理など）の結果をUIに反映する場合、メインループ内でUIを更新する必要があります。glib.IdleAddを使うことで、非同期処理の結果をメインループに通知し、安全にUIを更新することができます。

## 4.3 どこに気をつければ良いの？
4.1、4.2から、以下のようなことだと思います。
- GTK3ではUI操作はメインループにてシングルスレッドで実行されなければならない
- glib.IdleAddはメインループのキューにUI操作を登録する関数で、これを使えばマルチスレッドでも安全

では、シグナル処理内（シグナルハンドラ内）でUI操作をしても大丈夫でしょうか？  
> シグナル処理はメインループをブロックして実行されます。つまり、シグナルハンドラ内でUI操作を行っても、基本的にはメインループ内で同期的に実行されるため、通常はクラッシュを引き起こすことはありません。

ただ  

> シグナル処理中のUI操作で、アプリのクラッシュを誘発しない目的のみであれば、glib.IdleAddは必須ではありません。しかし、UIの応答性やパフォーマンスを向上させるために、状況に応じてglib.IdleAddを使用することを推奨します。

ということなので、「クラッシュはしないけど、シグナル処理内で長時間かかる処理の場合は考慮すること」という感じでしょうか。  

シングルスレッドにしないとクラッシュするという話は、UI操作の話だったと思い、Geminiに聞いてみました。
> - UI操作:
>   マルチスレッド環境でUI操作を行う場合は、glib.IdleAddを使用してメインスレッドにUI操作をキューイングする必要があります。
> - UI操作でない処理:
>   UI操作を伴わない処理であれば、Goルーチンを使用して並列に実行できます。

結論としては、故意にマルチスレッドで動くようなコードを書かなければ考慮は不要だと思いました。

## 4.4 マルチスレッドで気をつける
「故意にマルチスレッドで・・・」と記載しましたが、goルーチンを使った場合がこれにあたります。  
以下のコードはGemini作成のコードを抜粋した物ですが、「`*`」をつけた行でクラッシュする可能性があります。  

```
// 処理を行うGoルーチン
go func() {
	err := myfunc()
	if err != nil {
		// エラーメッセージを表示
		dialog := gtk.MessageDialogNew(・・・)    // *
		defer dialog.Destroy()                  // *
		dialog.Run()                            // *

		resultCh <- err
		return
	}
	resultCh <- nil
}()

// 結果を受け取るGoルーチン
go func() {
	err := <-resultCh
	if err != nil {
		// エラーメッセージを表示
		dialog := gtk.MessageDialogNew(・・・)    // *
		defer dialog.Destroy()                  // *
		dialog.Run()                            // *
		return
	}
	// 正常終了メッセージを表示
	dialog := gtk.MessageDialogNew(・・・)      // *
	defer dialog.Destroy()                    // *
	dialog.Run()                              // *
	close(resultCh)
}()
```

GUIアプリのgoルーチン内でエラーハンドリングをした時、ついついメッセージダイアログを使ってしまいます。  
また、「defer dialog.Destroy()」とかも見落としがちです。  
チャネル受信側も同様で、メッセージ表示や破棄などで注意が必要となります。  
「`*`」の行はglib.IdleAddを使ってクラッシュしないようにする必要があります。
